package com.dam.accesodatos.config;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * Configuración de base de datos para JDBC puro (sin Spring DataSource)
 *
 * Esta clase proporciona las propiedades de conexión para que los estudiantes
 * usen DriverManager.getConnection() directamente, aprendiendo JDBC vanilla.
 *
 * IMPORTANTE PEDAGÓGICO:
 * - Los estudiantes usarán DriverManager.getConnection() en cada método
 * - NO hay pool de conexiones de Spring
 * - Deben cerrar conexiones manualmente con try-with-resources
 * - Aprenden el ciclo completo de JDBC sin abstracciones
 */
public class DatabaseConfig {

    // Configuración H2 Database (en memoria)
    public static final String DB_URL = "jdbc:h2:mem:ra2db;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE";
    public static final String DB_USER = "sa";
    public static final String DB_PASSWORD = "";
    public static final String DB_DRIVER = "org.h2.Driver";

    private static boolean initialized = false;

    /**
     * Carga el driver JDBC de H2.
     *
     * Nota pedagógica:
     * En JDBC moderno (4.0+), DriverManager carga drivers automáticamente,
     * pero es buena práctica educativa hacer la carga explícita.
     *
     * Los estudiantes verán este patrón:
     * 1. Class.forName() carga la clase del driver
     * 2. El driver se registra automáticamente en DriverManager
     * 3. Luego se puede usar DriverManager.getConnection()
     */
    public static void loadDriver() {
        try {
            Class.forName(DB_DRIVER);
            System.out.println("✓ Driver JDBC H2 cargado correctamente: " + DB_DRIVER);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Error: No se pudo cargar el driver JDBC H2. " +
                    "Asegúrate de que h2database está en el classpath.", e);
        }
    }

    /**
     * Obtiene una conexión a la base de datos usando DriverManager.
     *
     * PATRÓN EDUCATIVO para estudiantes:
     *
     * try (Connection conn = DatabaseConfig.getConnection()) {
     *     // Usar la conexión
     * } catch (SQLException e) {
     *     throw new RuntimeException("Error: " + e.getMessage(), e);
     * }
     *
     * @return Connection JDBC
     * @throws SQLException si no se puede conectar
     */
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
    }

    /**
     * Inicializa la base de datos ejecutando scripts SQL.
     * Este método se llama una vez al arrancar la aplicación.
     *
     * NOTA: En producción, esto se haría con herramientas como Flyway o Liquibase,
     * pero aquí lo hacemos manualmente para propósitos educativos.
     */
    public static synchronized void initializeDatabase() {
        if (initialized) {
            return;
        }

        loadDriver();

        try (Connection conn = getConnection();
             Statement stmt = conn.createStatement()) {

            System.out.println("Inicializando base de datos H2...");

            // Ejecutar schema.sql
            executeScript(stmt, getSchemaSQL());
            System.out.println("✓ Schema creado correctamente");

            // Ejecutar data.sql
            executeScript(stmt, getDataSQL());
            System.out.println("✓ Datos de prueba insertados (8 usuarios)");

            initialized = true;
            System.out.println("✓ Base de datos inicializada exitosamente");

        } catch (SQLException e) {
            throw new RuntimeException("Error inicializando base de datos: " + e.getMessage(), e);
        }
    }

    /**
     * Ejecuta un script SQL compuesto de múltiples statements
     */
    private static void executeScript(Statement stmt, String script) throws SQLException {
        String[] statements = script.split(";");
        for (String sql : statements) {
            sql = sql.trim();
            if (!sql.isEmpty() && !sql.startsWith("--")) {
                stmt.execute(sql);
            }
        }
    }

    /**
     * Retorna el SQL del schema (CREATE TABLE, etc.)
     */
    private static String getSchemaSQL() {
        return """
            DROP TABLE IF EXISTS user_statistics CASCADE;
            DROP TABLE IF EXISTS users CASCADE;

            CREATE TABLE users (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                name VARCHAR(50) NOT NULL,
                email VARCHAR(100) UNIQUE NOT NULL,
                department VARCHAR(50) NOT NULL,
                role VARCHAR(50) NOT NULL,
                active BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );

            CREATE INDEX idx_users_department ON users(department);
            CREATE INDEX idx_users_role ON users(role);
            CREATE INDEX idx_users_active ON users(active);
            CREATE INDEX idx_users_email ON users(email);

            CREATE TABLE user_statistics (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id BIGINT NOT NULL,
                login_count INTEGER DEFAULT 0,
                last_login TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            )
            """;
    }

    /**
     * Retorna el SQL de datos de prueba (INSERT)
     */
    private static String getDataSQL() {
        return """
            INSERT INTO users (id, name, email, department, role, active, created_at, updated_at) VALUES
            (1, 'Juan Pérez', 'juan.perez@empresa.com', 'IT', 'Developer', true, '2024-01-15 09:30:00', '2024-01-15 09:30:00'),
            (2, 'María García', 'maria.garcia@empresa.com', 'HR', 'Manager', true, '2024-01-16 10:15:00', '2024-01-20 14:20:00'),
            (3, 'Carlos López', 'carlos.lopez@empresa.com', 'Finance', 'Analyst', true, '2024-01-17 11:00:00', '2024-01-17 11:00:00'),
            (4, 'Ana Martínez', 'ana.martinez@empresa.com', 'IT', 'Senior Developer', true, '2024-01-18 08:45:00', '2024-01-25 16:30:00'),
            (5, 'Luis Rodríguez', 'luis.rodriguez@empresa.com', 'Marketing', 'Specialist', true, '2024-01-19 13:20:00', '2024-01-19 13:20:00'),
            (6, 'Elena Fernández', 'elena.fernandez@empresa.com', 'IT', 'DevOps', false, '2024-01-20 09:00:00', '2024-02-01 10:00:00'),
            (7, 'Pedro Sánchez', 'pedro.sanchez@empresa.com', 'Sales', 'Representative', true, '2024-01-21 10:30:00', '2024-01-21 10:30:00'),
            (8, 'Laura González', 'laura.gonzalez@empresa.com', 'HR', 'Recruiter', true, '2024-01-22 14:00:00', '2024-01-22 14:00:00');

            INSERT INTO user_statistics (user_id, login_count, last_login) VALUES
            (1, 42, '2024-02-15 08:30:00'),
            (2, 28, '2024-02-14 16:45:00'),
            (3, 15, '2024-02-13 09:00:00'),
            (4, 67, '2024-02-15 07:15:00'),
            (5, 31, '2024-02-12 11:20:00')
            """;
    }

    /**
     * Información sobre la configuración actual
     */
    public static String getConfigInfo() {
        return String.format(
                "Configuración JDBC (Vanilla - sin Spring DataSource):%n" +
                "  - URL: %s%n" +
                "  - Usuario: %s%n" +
                "  - Driver: %s%n" +
                "  - Patrón: DriverManager.getConnection()",
                DB_URL,
                DB_USER,
                DB_DRIVER
        );
    }

    // Constructor privado para evitar instanciación
    private DatabaseConfig() {
        throw new AssertionError("DatabaseConfig no debe ser instanciada");
    }
}

